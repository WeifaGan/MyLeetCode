**题目链接**  
给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。

**注意:**  

num 的长度小于 10002 且 ≥ k。
num 不会包含任何前导零。

**示例1**  
```
输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。
```

**示例2**
```
输入: num = "10200", k = 1
输出: "200"
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
```

**解题思路**  
* 我们知道axxx和bxxx，只要a>b,那么axxx肯定大于bxxx,所以我们应该要最高位尽量地小，以1432219为例，对于最高位1，我们要保留1还是去掉？很明显是保留(1xxx<4xxxx)，下一个，
对于次高位4，我们要保留还是去掉，很明显是去掉，当去掉去就变成了新的数字，对于新的数字132219，我们还是要重头开始，最高位1保留吗?当然要，对于次高位3，当然要去掉。
好了，有变成了新的数字12219，对于最高位1，保留吗？当然，对于次高位，要保留吗？去留一样，保留，对于次次高位，去掉，因为121x<122x。好了贪心的思想出来了。对于每个位
保留还要去掉，其实是根据局部最优值得出的结果。
* 每一次得到新的数字都要重头再来，太麻烦了。有没有好的方法？我们能不能把重头再来那部分的重复去掉？对于某一串数字，例如把第三位去掉了，其实真正需要比较是
是第二位和新数字的第三位，所以我们可以利用栈的特性，其实就是栈顶元素跟下一位要进栈的元素比较。可以这个过程可以利用栈结构。
* 如果进栈结束后，还没去掉k个数字怎么办？那说明那数字是递增的。只需要把最后的去掉就行了。
* 贪心还是很经常跟栈，队列，堆这些数据结构一起操作的。
